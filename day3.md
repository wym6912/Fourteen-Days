## 第 3 天 搜索

第 3 天讲授的是搜索和模拟。今天毛老师讲的并不是很多，11 点就下课了。

模拟由于专题过大，就不太想写了（其实是不会...）。

[提高班第 3 天练习题](https://vjudge.net/contest/176280)

[入门班第 4 天练习题](https://cn.vjudge.net/contest/176664)

[入门班第 5 天练习题](https://cn.vjudge.net/contest/176912)

那么，我们从搜索开始吧。

#### 0. 搜索概论

搜索，就是暴力枚举各个**可达**结果，选择符合条件的结果，并将这些结果**按一定规则**保存起来。

结构是这样的：

1. 选择某一种可能情况向前探索。
   1. 探索过程中，若发现原来的选择是错误的，就退回一步重新选择，继续向前探索。
2. 反复进行1，直至得到解或证明无解。

如果这些话比较难理解的话，举个形象的例子：

* 迷宫问题：进入迷宫后，先随意选择一个前进方向，一步步向前试探前进,如果碰到死胡同，说明前进方向已无路可走，这时，首先看其它方向是否还有路可走，如果有路可走，则沿该方向再向前试探；如果已无路可走，则返回一步，再看其它方向是否还有路可走；如果有路可走，则沿该方向再向前试探。按此原则不断搜索回溯再搜索，直到找到新的出路或从原路返回入口处无解为止。

搜索的分类：

1. 盲目搜索：   \(按预定的控制策略进行搜索，在搜索过程中获得的中间信息不用来改进控制策略。\)
   1. 广度优先搜索（Breadth First Search）    
   2. 深度优先搜索（Depth First Search）   
   3. 纯随机搜索、重复式搜索、迭代加深搜索、迭代加宽搜索、柱型搜索 
2. 启发式搜索：    \(在搜索中加入了与问题有关的启发性信息，用以指导搜索朝着最有希望的方向发展，加速问题的求解过程并找到最优解。\)
3. 1. A\*算法
   2. IDA\*算法

本文重点讲述 1.i 和 1.ii。

#### 1. 深度优先搜索（Depth First Search，简称 DFS）

定义：在搜索时以深度为优先，进行扩展答案的一种方法。（拿了以前的框架。。。）

DFS算法框架\(I\)

```cpp
int DFS(int k) 　
{ 　
    for (i = 1;i <= 算符种数;i ++) 　　
        if (满足条件) 　　   
        { 　　　　
            保存结果 　　　　
            if (到目的地) 输出解; 　　　           
            else DFS(k + 1); 　　　　
            恢复：保存结果之前的状态{回溯一步} 　 　  
        } 　
}
```

DFS算法框架\(II\)

```cpp
int DFS(int k) 　
{ 　  
    if  (到目的地) 输出解;
    else 　　　　
        for (i = 1;i <= 算符种数;i ++) 　　　　　
            if  (满足条件)  　　　　　　　
            {
                保存结果;
                DFS(k + 1); 　　　　　　　　
                恢复：保存结果之前的状态{回溯一步} 　　　　　　　
            } 　
}
```

当然，如果这样的话，它的时间复杂度是$$O(Status ^ n)$$，复杂度虽说比$$O(n!)$$稍小一点，但是这个复杂度仍然让人无法接受。

例题：[HDU 1016](http://acm.hdu.edu.cn/showproblem.php?pid=1016)，素数环：从`1`到`20`这`20`个数摆成一个环，要求相邻的两个数的和是一个素数。递归填数：判断第$$i$$个数填入是否合法。

这个时候，就需要**剪枝**了。

剪枝大致分为 可行性剪枝 和 最优化剪枝。

可行性剪枝 就是尽早将不可能到达的点剪去，以在**保证正确性**的前提下，快速完成搜索的目的。

例题：[HDU 2553](http://acm.hdu.edu.cn/showproblem.php?pid=2553) ，多皇后问题：皇后能吃同一行、同一列、同一对角线的任意棋子，如何放置才能让他们不互相吃？

以 8 皇后为例，显然问题的关键在于如何判定某个皇后所在的行、列、斜线上是否有别的皇后；可以从矩阵的特点上找到规律，如果在同一行，则行号相同；如果在同一列上，则列号相同；如果同在／ 斜线上的行列值之和相同；如果同在＼ 斜线上的行列值之差相同，利用下图可以验证。

![](/PIC_Day3_1.jpg)

考虑每行有且仅有一个皇后，设一维数组A\[8\]\[8\]表示皇后的放置：第i行皇后放在第j列，用A\[i\]=j来表示，即下标是行数，内容是列数。例如：A\[3\]=5就表示第3个皇后在第3行第5列上。



