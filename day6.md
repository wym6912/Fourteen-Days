## 第 6 天 线段树\(II\) 区间修改 线段树的问题转换

今天依旧是 V8 老师。一去上课，他就提问我：“这个数列有什么规律吗？”我：“???”

[提高班第 6 天练习题](/vjudge.net/contest/177295)

[入门班第 8 天练习题](https://vjudge.net/contest/177627)

[入门班第 9 天练习题](https://vjudge.net/contest/177956)

今天开始接着昨天的论题，区间修改、问题转换。

#### 1. 线段树的区间修改

按照昨天的说法，线段树的区间修改的复杂度是$$O( \log {N})$$，但是更新的区间如果退化成了一个点，那么更新的复杂度期望为$$O(N \log {N})$$，甚至不及数组。

所以我们需要一个东西：标记下传。

例题：[POJ 3468](http://poj.org/problem?id=3468)，这道题我们需要去从更新区间，查询区间和。

按照样例：

```
10 3
1 2 3 4 5 6 7 8 9 10
C 2 9 3
Q 2 4
```

对于修改操作，类比询问操作的思想，也是沿着两条链下去修改每一段子区间，不过这里出现了一个问题：如右图如果修改区间$$[2,9]$$，但是修改到$$[6,8]$$时就已经结束了，这样的话，$$[6,7], [8,8], [6,6], [7,7]$$这四段区间并没有修改。

![](/PIC_Day6_1.png)

lazy 思想可以解决这个问题。再更新的地方如下所示：

![](/PIC_Day6_2.png)

我们对于线段树上的每个结点再维护一个$$lazy$$值，如图，假设$$[6, 8]$$区间的编号为$$rt$$。当我们给$$[6,8]$$加$$c$$时，同时`lazy[rt] += c`。表示有一个$$+ c$$的修改还没有传下去，这样的话，当我们查询$$[6,7] , [8,8], [6,6], [7,7]$$时，再将修改传下去就行了。

首先，我们需要把数字读入。

```cpp
void pre(int l, int r, int p)
{
	tree[p].l = l;
	tree[p].r = r;
	if(l == r)
	{
		scan_d(tree[p].tag);
		pushup(p, l, r);//注意在计算的位置 
		return ;
	}
	int mid = midf(l, r);
	pre(l, mid, DXA(p));
	pre(mid + 1, r, DXB(p));
	pushup(p, l, r);
}
```

首先完成上传结果函数：

```cpp
void pushup(int p, int l, int r)
{
	tree[p].data = 0;
	if(r > l) //注意这个是根节点
	{
		tree[p].data += tree[DXA(p)].data + tree[DXB(p)].data;
	}
	tree[p].data += tree[p].tag * (r - l + 1);//自己已经更新
}
```



